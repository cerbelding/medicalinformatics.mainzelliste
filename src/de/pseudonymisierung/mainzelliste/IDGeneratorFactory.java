/*
 * Copyright (C) 2013-2015 Martin Lablans, Andreas Borg, Frank Ãœckert
 * Contact: info@mainzelliste.de
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the Free 
 * Software Foundation; either version 3 of the License, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT 
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU Affero General Public License 
 * along with this program; if not, see <http://www.gnu.org/licenses>.
 *
 * Additional permission under GNU GPL version 3 section 7:
 *
 * If you modify this Program, or any covered work, by linking or combining it 
 * with Jersey (https://jersey.java.net) (or a modified version of that 
 * library), containing parts covered by the terms of the General Public 
 * License, version 2.0, the licensors of this Program grant you additional 
 * permission to convey the resulting work.
 */
package de.pseudonymisierung.mainzelliste;

import de.pseudonymisierung.mainzelliste.crypto.Encryption;
import de.pseudonymisierung.mainzelliste.dto.Persistor;
import de.pseudonymisierung.mainzelliste.exceptions.GeneralCryptoException;
import de.pseudonymisierung.mainzelliste.exceptions.InvalidConfigurationException;
import de.pseudonymisierung.mainzelliste.exceptions.InvalidIDException;
import de.pseudonymisierung.mainzelliste.util.ConfigUtils;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Properties;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.apache.commons.lang3.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.codehaus.jettison.json.JSONException;
import org.codehaus.jettison.json.JSONObject;

/**
 * Factory for IDGenerators. Implemented as a singleton object, which can be
 * referenced by IDGeneratorFactory.instance.
 */
public enum IDGeneratorFactory {

	/** The singleton instance. */
	instance;

	/** Map of generators, with respective ID types as keys. */
	private final Map<String, IDGenerator<? extends ID>> generators;

	/** Map of generators, with respective associatedIds type as keys. */
	private final Map<String, List<IDGenerator<? extends ID>>> associatedIdGenerators;

	/**
	 * The configured ID types. Must be saved separately as the order is
	 * important for determining the default ID type (see getDefaultIDType())
	 */
	private String[] idTypes;

	private HashSet<String> extIdTypes;

	/** Set of ID types which should not persisted in DB (e.g. ID types generated by encryption) */
	private HashSet<String> transientIdTypes;

	/** Map of export encryption, with respective ID types as keys. */
	private final Map<String, Encryption> exportEncryptions = new HashMap<>();

	private final Map<String, Encryption> inputEncryptions = new HashMap<>();

	/** the configured eager generation flag */
	private final boolean eagerGenerationOn;

	/** The logging instance */
	private Logger logger = LogManager.getLogger(this.getClass());

	/**
	 * Initializes the IDGeneratorFactory. Reads the configuration and sets up
	 * the necessary IDGenerator instances, which are initialized with the
	 * settings stored in the database (see {@link IDGeneratorMemory}).
	 */
	private IDGeneratorFactory() {
		Properties props = Config.instance.getProperties();

		if (!props.containsKey("idgenerators")
				|| props.getProperty("idgenerators").length() == 0) {
			logger.fatal("No ID generators defined!");
			throw new Error("No ID generators defined!");
		}

		// split list of ID generators: comma-separated, ignore whitespace
		// around commas
		this.idTypes = props.getProperty("idgenerators").split("\\s*,\\s*");

		generators = Collections.unmodifiableMap(readIdGenerators(props, idTypes));

		// Find the set of special id types (external ID types / transient ID types)
		extIdTypes = new HashSet<>();
		transientIdTypes = new HashSet<>();
		for (IDGenerator<? extends ID> idGenerator : this.generators.values()) {
			if (idGenerator.isExternal()) {
				extIdTypes.add(idGenerator.getIdType());
			} else if (!idGenerator.isPersistent()) {
				transientIdTypes.add(idGenerator.getIdType());
			}
		}

		// read the configured eager generation flag
		try {
			this.eagerGenerationOn = ConfigUtils
					.readValue(props, "idgenerators.eagerGeneration", false);
		} catch (InvalidConfigurationException e) {
			logger.error(e.getMessage());
			throw e;
		}

		this.associatedIdGenerators = new HashMap<>();
		ConfigUtils.getVariableSubProperties(props,"associatedids").forEach((t, p) -> {
			String[] associatedIdTypes = p.getProperty("idgenerators").split("\\s*,\\s*");
			associatedIdGenerators.put(t, new ArrayList<>(readIdGenerators(props, associatedIdTypes).values()));
		});
		logger.info("ID generators have initialized successfully.");
	}

	private Map<String, IDGenerator<? extends ID>> readIdGenerators(Properties props, String[] idTypes) {
		HashMap<String, IDGenerator<? extends ID>> temp = new HashMap<String, IDGenerator<? extends ID>>();
		// Iterate over ID types
		for (String thisIdType : idTypes) {
			PropertyIterator propIt = new PropertyIterator(props, "idgenerator." + thisIdType);
			String thisIdGenerator = propIt.getProperty("", "");
			try {
				// Add mainzelliste package to class name if none is given
				// (check by searching for a dot in the class name)
				if (!thisIdGenerator.contains("."))
					thisIdGenerator = "de.pseudonymisierung.mainzelliste."
							+ thisIdGenerator;
				IDGenerator<?> thisGenerator = (IDGenerator<?>) Class.forName(
						thisIdGenerator).newInstance();
				IDGeneratorMemory mem = Persistor.instance
						.getIDGeneratorMemory(thisIdType);
				if (mem == null) {
					// Create new memory object and persist.
					mem = new IDGeneratorMemory(thisIdType);
					Persistor.instance.updateIDGeneratorMemory(mem);
					/*
					 * Reread from persistence to ensure to get a persisted
					 * entity. Otherwise future updates generate new objects in
					 * the database.
					 */
					mem = Persistor.instance.getIDGeneratorMemory(thisIdType);
				}

				// Get properties for this ID generator
				Properties thisIdProps = new Properties();
				for (Object key : propIt.keyIterator()) {
					if (key instanceof String) {
						thisIdProps.put(key, propIt.getProperty((String)key, ""));
					}
				}

				// init export encryption
				String exportEncryption = StringUtils
						.trimToEmpty((String) thisIdProps.get("exportEncryption"));
				if (!exportEncryption.isEmpty()) {
					if (Config.instance.getEncryption(exportEncryption) != null) {
						exportEncryptions.put(thisIdType, Config.instance.getEncryption(exportEncryption));
					} else {
						throw new InvalidConfigurationException(
								"idgenerator." + thisIdType + ".exportEncryption",
								"the given export encryption not configured");
					}
				}

				// init input encryption
				String inputEncryption = StringUtils
						.trimToEmpty((String) thisIdProps.get("inputEncryption"));
				if (!inputEncryption.isEmpty()) {
					if (Config.instance.getEncryption(inputEncryption) != null) {
						inputEncryptions.put(thisIdType, Config.instance.getEncryption(inputEncryption));
					} else {
						throw new InvalidConfigurationException(
								"idgenerator." + thisIdType + ".inputEncryption",
								"the given input encryption not configured");
					}
				}

				// read the configured ID types with which the current generator will create the ID
				String eagerConfigValue = StringUtils.trimToEmpty((String) thisIdProps.get("eager"));
				String[] eagerGenRelatedIdTypes =
						eagerConfigValue.isEmpty() ? new String[0] : eagerConfigValue.split("\\s*,\\s*");
				//validate configuration
				List<String> notFoundIdTypes = Stream.of(eagerGenRelatedIdTypes)
						.filter(i -> !i.trim().equals("*"))
						.filter(i -> Stream.of(idTypes).noneMatch(i::equals))
						.collect(Collectors.toList());
				if (!notFoundIdTypes.isEmpty()) {
					throw new InvalidConfigurationException(
							"idgenerator." + thisIdType + ".eager",
							"following id types : " + String.join(", ", notFoundIdTypes) + " not configured");
				}
				thisGenerator.init(mem, thisIdType, eagerGenRelatedIdTypes, thisIdProps);
				temp.put(thisIdType, thisGenerator);
			} catch (InvalidConfigurationException e) {
				logger.error(e.getMessage());
				throw e;
			} catch (ClassNotFoundException e) {
				logger.fatal("Unknown ID generator " + thisIdGenerator + " for id type " + thisIdType);
				throw new Error(e);
			} catch (Exception e) {
				logger.fatal("Could not initialize ID generator " + thisIdGenerator + " for id type " + thisIdType, e);
				throw new Error(e);
			}
		}
		return temp;
	}

	/**
	 * Get the IDGenerator for the given ID type.
	 * 
	 * @param idType
	 *            The ID type for which to get the IDGenerator.
	 * @return The respective IDGenerator instance or null if the given ID type
	 *         is unknown.
	 */
	public IDGenerator<? extends ID> getFactory(String idType) {
		return generators.get(idType);
	}

	public IDGenerator<? extends ID> getGenerator(String idType) {
		IDGenerator<? extends ID> generator = generators.get(idType);
		if (generator == null) {
			generator = associatedIdGenerators.values().stream()
					.flatMap(Collection::stream)
					.filter(g -> g.getIdType().equals(StringUtils.trimToEmpty(idType)))
					.findAny().orElse(null);
		}
		return generator;
	}

	/**
	 * Returns a map of IDGenerators for internal ID type
	 *
	 * @return a map of IDGenerators for internal ID type.
	 */
	public Map<String, IDGenerator<? extends ID>> getNonExternalIdGenerators() {
		return generators.entrySet().stream()
				.filter(e -> !e.getValue().isExternal())
				.collect(Collectors.toMap(Entry::getKey, Entry::getValue));
	}

	/**
	 * Generates a set of IDs for a new patient by calling every ID generator
	 * defined in the configuration.
	 * For external IDs no values are generated
	 * 
	 * @return The set of generated IDs.
	 */
	public Set<ID> generateIds() {
		return generateIds(this.generators.keySet());
	}

	/**
	 * Generates a set of IDs for a new patient by calling the appropriate ID
	 * generator for every requested ID type. For external IDs no values are
	 * generated.
	 * 
	 * @param idTypes
	 *            Types of the IDs to generate. Duplicates are removed from this
	 *            parameter, i.e. not more than one ID per ID type will be
	 *            generated.
	 * @return The set of generated IDs.
	 * @throws NullPointerException if the specified collection is null
	 */
	public Set<ID> generateIds(Collection<String> idTypes) {
		HashSet<String> idTypesDedup = new HashSet<String>(idTypes);
		HashSet<ID> ids = new HashSet<ID>();
		for (String idType : idTypesDedup) {
			if (!this.generators.get(idType).isExternal())
				ids.add(this.generators.get(idType).getNext());
		}
		return ids;
	}

	/**
	 * Get all {@link IDGeneratorMemory}s
	 * @return A set of id generator memories
	 */
	public Set<IDGeneratorMemory> getGeneratorMemories() {
		return this.generators.values().stream()
						.map(IDGenerator::getMemory)
						.filter(Optional::isPresent)
						.map(Optional::get)
						.collect(Collectors.toSet());
	}

	/**
	 * Get all {@link IDGeneratorMemory}s of associated Ids
	 * @return A set of id generator memories
	 */
	public Set<IDGeneratorMemory> getAssociatedIdGeneratorMemories() {
		return this.associatedIdGenerators.values().stream()
				.flatMap(Collection::stream)
				.map(IDGenerator::getMemory)
				.filter(Optional::isPresent)
				.map(Optional::get)
				.collect(Collectors.toSet());
	}

	/**
	 * Get set of external id types
	 *
	 * @return The set of external id types.
	 */
	public Set<String> getExternalIdTypes() {
		return this.extIdTypes;
	}

	/**
	 * Get set of transient id types
	 *
	 * @return The set of transient id types.
	 */
	public Set<String> getTransientIdTypes() {
		return this.transientIdTypes;
	}

	/**
	 * Get names of defined id types as an array. The result must not be
	 * modified.
	 * 
	 * @return The defined id types.
	 */
	public String[] getIDTypes() {
		return this.idTypes;
	}

	/**
	 * check if the given primary id type exist
	 * @param idType primary id type
	 * @return true if exist
	 */
	public boolean isIdTypeExist(String idType) {
		return Arrays.asList(idTypes).contains(StringUtils.trimToEmpty(idType));
	}

	/**
	 * Get the default id type (currently, the first one defined in the
	 * configuration).
	 * 
	 * @return The default id type.
	 */
	public String getDefaultIDType() {
		return this.idTypes[0];
	}

	/**
	 * get all IdGenerators belonging to the given associatedIds type
	 * @param associatedIdsType searched associatedIds type
	 * @return list of id generators
	 */
	public Set<IDGenerator<? extends ID>> getAssociatedIdGenerators(String associatedIdsType) {
		return new HashSet<>(associatedIdGenerators.get(associatedIdsType));
	}

	/**
	 * get all non external IdGenerators belonging to the given associatedIds type
	 * @param associatedIdsType searched associatedIds type
	 * @return list of id generators
	 */
	public Set<IDGenerator<? extends ID>> getNonExtAssociatedIdGenerators(String associatedIdsType) {
		return associatedIdGenerators.getOrDefault(associatedIdsType, Collections.emptyList()).stream()
				.filter(e -> !e.isExternal())
				.collect(Collectors.toSet());
	}

	/**
	 * get all external associated id types
	 *
	 * @return The set of external id types.
	 */
	public List<String> getExternalAssociatedIdTypes() {
		return associatedIdGenerators.entrySet().stream()
				.flatMap( e -> e.getValue().stream().filter(IDGenerator::isExternal))
				.map(IDGenerator::getIdType)
				.collect(Collectors.toList());
	}

	/**
	 * find associatedIds type the given id type belong to
	 * @param idType id type
	 * @return associatedIds type
	 * @exception IllegalArgumentException if no associatedIds type found
	 */
	public String getAssociatedIdsType(String idType) {
		return associatedIdGenerators.entrySet().stream()
				.filter(e -> e.getValue().stream()
						.anyMatch(g -> g.getIdType().equals(StringUtils.trimToEmpty(idType))))
				.map(Entry::getKey)
				.findAny()
				.orElseThrow(() -> new IllegalArgumentException("no associatedIdsType found for the given "
						+ "id types: " + idType));
	}

	/**
	 * check if the given associated id type exist
	 * @param idType associated id type
	 * @return true if exist
	 */
	public boolean isAssociatedIdTypeExist(String idType) {
		return associatedIdGenerators.values().stream()
				.anyMatch( l -> l.stream().anyMatch( g -> g.getIdType().equals(StringUtils.trimToEmpty(idType))));
	}

	/**
	 * Get export id encryption
	 *
	 * @return null if no such entry is found
	 */
	public Encryption getExportEncryption(String idType) {
		return this.exportEncryptions.get(idType);
	}

	public Encryption getInputEncryption(String idType) {
		return this.inputEncryptions.get(idType);
	}

	/**
	 * return whether IDs of all configured types should be created for a given patient eagerly
	 *
	 * @return true if eager generation of patient IDs is enabled
	 */
	public boolean isEagerGenerationOn() {
		return this.eagerGenerationOn;
	}

	public ID idFromJSON(JSONObject json) throws JSONException, InvalidIDException {
		if (!json.has("idType") && json.has("idString"))
			throw new JSONException("Illegal format for ID. Need at least members 'idType' and 'idString'");
		
		IDGenerator<?> generator = IDGeneratorFactory.instance.getFactory(json.getString("idType"));
		if (generator == null) {
			String message = String.format("No ID generator %s found!", json.getString("idType")); 
			logger.error(message);
			throw new InvalidIDException();
		}
		ID id = generator.buildId(json.getString("idString"));
		
		if (json.has("tentative"))
			id.setTentative(json.getBoolean("tentative"));
		else
			id.setTentative(false);
		
		return id;
	}
	
	/**
	 * Build an ID with the given ID string and type.
	 * 
	 * @param idType
	 *            The ID type.
	 * @param idString
	 *            The ID string.
	 * @return An ID instance with the given properties.
	 * @throws InvalidIDException
	 *             If the given id type is unknown.
	 */
	public ID buildId(String idType, String idString) {
		if (this.getFactory(idType) == null)
			throw new InvalidIDException(String.format(
					"No ID type %s defined!", idType));

		return this.getFactory(idType).buildId(idString);
	}

	/**
	 * Build an ID with the given ID string (or decrypted ID string) and type.
	 *
	 * @param idType
	 *            The ID type.
	 * @param idString
	 *            The ID string.
	 * @return An ID instance with the given properties.
	 * @throws InvalidIDException
	 *             If the given id type is unknown.
	 */
	public ID decryptAndBuildId(String idType, String idString) {
		Encryption encryption = IDGeneratorFactory.instance.getInputEncryption(idType);
		try {
			// if input encryption isn't defined for idType, take plain id string
			// otherwise decrypt id string before building id
			String resultIdString = encryption != null ? encryption.decryptToString(idString) : idString;
			return IDGeneratorFactory.instance.buildId(idType,resultIdString);
		} catch (GeneralSecurityException e) {
			throw new GeneralCryptoException(
					"Decryption of ID[type:" + idType + "," + idString.length() + " failed", e);
		}
	}
}
